# CPU戦におけるマリガン処理消失の修正

## 概要

CPU戦を開始した際、プレイヤーにマリガンの選択画面が表示されず、ゲームが進行しない（またはCPUのみがマリガンを行う）問題を修正しました。

## 原因

`Game.start()` メソッドにおいて、全プレイヤーに対してループで `requestSelection`（マリガンの要求）を行っていました。
`Game` クラスは単一の `selection` ステート（`this.selection`）しか持たないため、後から実行されるプレイヤー（通常はCPU）のリクエストが、先に実行されたプレイヤー（ユーザー）のリクエストを上書きしていました。
結果として、ユーザー側のクライアントは「相手が選択中」と認識し、マリガン画面が表示されませんでした。

## 対応内容

マリガンのリクエストを**順次処理（Sequential Flow）**に変更しました。

### 変更点: `server/Game.ts`

1. **`start()` メソッドの変更**:
    * ループ内での `requestSelection` 呼び出しを削除しました。
    * 代わりに、新規追加した `proceedMulligan()` メソッドを呼び出すようにしました。

2. **`proceedMulligan()` ヘルパーメソッドの追加**:
    * `mulliganDone` が `false` のプレイヤーを検索し、最初に見つかったプレイヤーに対してのみ `requestSelection` を発行します。
    * 全員が完了している場合は、ゲームフェーズを `LEVEL_UP` に進めます。

3. **`resolveSelection` / `resolveMulligan` の更新**:
    * プレイヤーがマリガンを完了した後、`this.proceedMulligan()` を呼び出して、次のプレイヤーのマリガン処理（またはゲーム開始）に移行するようにしました。
    * `resolveSelection` の末尾において、新しくリクエストされた `this.selection` を誤ってクリアしてしまわないよう、`return` 処理を追加しました。
    * 手札上限（7枚）によるディスカードが発生した場合も、処理完了後に `END` フェーズへ正しく復元されるように修正しました。

4. **`AIPlayer.ts` の `END` フェーズ対応**:
    * `think()` メソッドに `case 'END'` を追加し、CPUがエンドフェーズにおいて自ら `nextPhase`（ターンの終了）を宣言するように修正しました。

## 結果

ユーザーがマリガンを完了した後、正常にゲームが進行し、CPUのターンもエンドフェーズを経て正しくプレイヤーに引き継がれるようになりました。手札上限によるディスカードが発生した場合も、適切にフェーズが復元されます。
