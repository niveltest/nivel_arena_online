
import { Player } from './Player';
import { GameState, Card, CardEffect } from '../shared/types';
import cardsData from './data/cards.json';
import { v4 as uuid } from 'uuid';
import { validateDeck } from './deckValidation';

export class Game {
    public id: string;
    public players: Record<string, Player> = {};
    public phase: GameState['phase'] = 'WAITING';
    public turnPlayerId: string = '';
    public turnCount: number = 0;
    public debugLogs: string[] = [];

    public pendingAttack: { attackerId: string, attackerIndex: number, defenderId: string, targetIndex: number } | null = null;
    public selection: { playerId: string, type: 'DECK' | 'DISCARD' | 'HAND' | 'FIELD' | 'DAMAGE_ZONE', candidateIds: string[], count: number, action: string, context?: Record<string, unknown>, triggerCard?: Card, previousPhase: GameState['phase'] } | null = null;

    public constructor(id: string) {
        this.id = id;
    }

    private hasKeyword(card: Card, keyword: string): boolean {
        if (!card) return false;
        const mapping: Record<string, string> = {
            'アタッカー': 'アタッカー',
            'ATTACKER': 'アタッカー',
            'PENETRATION': 'PENETRATION_',
            'LOOT': 'LOOT_',
            'BERSERKER': 'バーサーカー',
            'DUELIST': 'デュエリスト',
            'DEATH_TOUCH': '道連れ',
            'INVINCIBLE': '無敵',
            'ITEM_SHIELD': '装備ガード',
            'BREAKTHROUGH': '突破',
            'INFILTRATE': '潜入',
            'GUARDIAN': '防壁'
        };

        const eng = keyword.toUpperCase();
        const prefix = mapping[eng] || keyword;

        const checkMatch = (kw: string) => {
            if (kw === eng || kw === prefix) return true;
            if (prefix.endsWith('_') && kw.startsWith(prefix)) return true;
            return false;
        };

        if (card.keywords?.some(checkMatch)) return true;
        if (card.tempKeywords?.some(checkMatch)) return true;

        const jp = (eng === 'PENETRATION') ? '貫通' : (eng === 'LOOT' ? '略奪' : prefix);

        // Check attached items for keywords
        if (card.attachments) {
            for (const item of card.attachments) {
                if (item.keywords?.some(checkMatch)) return true;
                if (item.text?.includes(jp)) return true;
            }
        }

        if (card.text?.includes(jp)) {
            if (card.text.includes('《ユニーク》を持つアイテムを装備している場合')) {
                const hasUnique = card.attachments?.some(item =>
                    item.affiliation?.includes('ユニーク') || item.text?.includes('《ユニーク》') || item.name?.includes('ユニーク')
                );
                if (!hasUnique) return false;
            }

            if (card.text.includes('枚以上なら') && card.text.includes(jp)) {
                const match = card.text.match(/(\d+)枚以上なら/);
                if (match) {
                    const threshold = parseInt(match[1], 10);
                    const itemNum = card.attachments?.length || 0;
                    if (itemNum < threshold) return false;
                }
            }
            return true;
        }

        return false;
    }

    private getKeywordValue(card: Card, keyword: string): number {
        if (!card) return 0;
        const mapping: Record<string, string> = {
            'PENETRATION': 'PENETRATION_',
            'LOOT': 'LOOT_'
        };
        const prefix = mapping[keyword.toUpperCase()] || (keyword.toUpperCase() + '_');


        const jp = (keyword.toUpperCase() === 'PENETRATION') ? '貫通' : '略奪';

        const getVal = (c: Card): number => {
            const kws = [...(c.keywords || []), ...(c.tempKeywords || [])];
            const match = kws.find(kw => kw.startsWith(prefix));
            if (match) {
                const val = parseInt(match.replace(prefix, ''), 10);
                return isNaN(val) ? 1 : val;
            }
            const textMatch = c.text?.match(new RegExp(`\\[?${jp}\\]?\\[(\\d+)\\]`));
            if (textMatch) return parseInt(textMatch[1], 10);
            if (c.text?.includes(jp)) return 1;
            return 0;
        };

        let maxValue = getVal(card);

        if (card.attachments) {
            card.attachments.forEach(item => {
                maxValue = Math.max(maxValue, getVal(item));
            });
        }

        return maxValue;
    }

    public addPlayer(player: Player) {
        if (Object.keys(this.players).length >= 2) return false;
        this.players[player.id] = player;
        return true;
    }

    public handleDisconnect(socketId: string) {
        if (this.phase === 'FINISHED') return;
        const playerId = socketId; // Assuming playerId is socketId initially
        const player = this.players[playerId];

        if (player) {
            player.connected = false;
            // 60 sec timer
            if (player.disconnectTimeout) clearTimeout(player.disconnectTimeout);
            player.disconnectTimeout = setTimeout(() => {
                this.endGame(playerId, "接続切れによる敗北");
            }, 60000);

            this.broadcastAction(playerId, 'PLAYER_DISCONNECTED', {
                playerId,
                timeoutSec: 60
            });
            this.addLog(`${player.username} Disconnected. Waiting for reconnect...`);
        }
    }

    public handleReconnect(username: string, newSocketId: string): { success: boolean, oldSocketId?: string } {
        if (this.phase === 'FINISHED') return { success: false };

        const existingPlayerId = Object.keys(this.players).find(id => this.players[id].username === username);
        if (!existingPlayerId) return { success: false };

        const player = this.players[existingPlayerId];

        // Clear timeout
        if (player.disconnectTimeout) {
            clearTimeout(player.disconnectTimeout);
            player.disconnectTimeout = null;
        }

        player.connected = true;

        // Typically we need to update playerId in 'players' map if playerId IS socketId.
        // But changing key in map is tricky references.
        // Instead, we might need to handle ID migration or just keep old ID internally but map socket events.
        // Simplest for now: Migrate the player entry to new Key.

        // Remove old key
        delete this.players[existingPlayerId];
        // Add new key
        this.players[newSocketId] = player;
        player.id = newSocketId;
        player.state.id = newSocketId; // State also has ID

        // If it was this player's turn, update turnPlayerId reference? 
        if (this.turnPlayerId === existingPlayerId) {
            this.turnPlayerId = newSocketId;
        }

        this.broadcastAction(newSocketId, 'PLAYER_RECONNECTED', {
            playerId: newSocketId,
            username
        });
        this.addLog(`${username} Reconnected!`);

        // Send full state to reconnected player
        return { success: true, oldSocketId: existingPlayerId };
    }

    public removePlayer(playerId: string) {
        // Only used for cleanup or force removal. Normal disconnect calls handleDisconnect
        delete this.players[playerId];
        if (Object.keys(this.players).length < 2) {
            this.phase = 'WAITING';
            this.turnCount = 0;
        }
    }

    public start() {
        if (Object.keys(this.players).length < 2) return;

        console.log('[Game] STARTING GAME');
        this.phase = 'MULLIGAN';
        this.turnCount = 1;
        this.turnPlayerId = Object.keys(this.players)[0];
        this.addLog(`Game Started! P1=${this.players[this.turnPlayerId].username}`);

        const allCards = cardsData as unknown as Card[];

        const getCompatibleCards = (leader: Card, pool: Card[]) => {
            return pool.filter(c =>
                c.type !== 'LEADER' &&
                c.attribute === leader.attribute
            );
        };

        const createDeckInstance = (baseCards: Card[]): Card[] => {
            return baseCards.map(c => ({ ...c, id: uuid() } as Card));
        };

        Object.values(this.players).forEach(p => {
            if (p.deckData) {
                const leader = allCards.find(c => c.id === p.deckData?.leaderId);
                if (leader) p.state.leader = { ...leader, id: uuid() };
                else p.state.leader = { ...allCards.find(c => c.type === 'LEADER')! };
                p.state.leaderLevel = 1;
                const deckIds = p.deckData.deckIdList;
                const rawDeck = deckIds.map(id => allCards.find(c => c.id === id)).filter((c): c is Card => !!c);
                p.state.deck = createDeckInstance(rawDeck);
                p.state.deck.sort(() => Math.random() - 0.5);
            } else {
                const leaders = allCards.filter(c => c.type === 'LEADER');
                const baseLeader = leaders[Math.floor(Math.random() * leaders.length)];
                p.state.leader = { ...baseLeader, id: uuid() } as Card;
                p.state.leaderLevel = 1;
                const rawDeck: Card[] = [];
                const compatible = getCompatibleCards(baseLeader, allCards);
                const cardCounts = new Map<string, number>();
                while (rawDeck.length < 40) {
                    const base = compatible[Math.floor(Math.random() * compatible.length)];
                    const count = cardCounts.get(base.id) || 0;
                    if (count >= 3) continue;
                    rawDeck.push(base);
                    cardCounts.set(base.id, count + 1);
                }
                p.state.deck = createDeckInstance(rawDeck);
            }

            p.state.unitsPlaced = [false, false, false];
            p.state.skillZone = [];
            p.state.mulliganDone = false;
            for (let i = 0; i < 5; i++) {
                if (p.state.deck.length > 0) {
                    p.drawCard(p.state.deck.pop()!);
                }
            }
        });

        this.broadcastState();
    }

    public switchTurn() {
        const oldPlayer = this.players[this.turnPlayerId];
        if (oldPlayer) {
            oldPlayer.state.field.forEach(u => {
                if (u) {
                    if (u.tempPowerDebuff) u.tempPowerDebuff = 0;
                    if (u.tempPowerBuff) u.tempPowerBuff = 0;
                    if (u.tempHitBuff) u.tempHitBuff = 0;
                    if (u.tempKeywords) u.tempKeywords = [];
                    if (u.cannotAttack && !this.hasKeyword(u, 'PERMANENT_CANNOT_ATTACK')) u.cannotAttack = false;
                    u.activeUsedThisTurn = false;
                    u.attackedThisTurn = false;
                }
            });
        }

        const playerIds = Object.keys(this.players);
        const currentIdx = playerIds.indexOf(this.turnPlayerId);
        const nextIdx = (currentIdx + 1) % playerIds.length;
        this.turnPlayerId = playerIds[nextIdx];
        this.turnCount++;
        this.phase = 'LEVEL_UP';
        this.addLog(`Turn ${this.turnCount}: ${this.players[this.turnPlayerId].username}'s turn`);

        const nextPlayer = this.players[this.turnPlayerId];
        nextPlayer.state.field.forEach(u => {
            if (u && u.isStunned) u.isStunned = false;
        });
        nextPlayer.state.unitsPlaced = [false, false, false];

        this.handleLevelUpPhase();
        this.broadcastState();
    }

    public nextPhase() {
        switch (this.phase) {
            case 'LEVEL_UP':
                this.phase = 'DRAW';
                this.handleDrawPhase();
                break;
            case 'DRAW':
                this.phase = 'MAIN';
                break;
            case 'MAIN':
                this.phase = 'ATTACK';
                break;
            case 'ATTACK':
                if (this.checkBerserkerMustAttack()) {
                    this.addLog(`バーサーカーを持つユニットが攻撃していません。必ず攻撃を行ってください。`);
                    return;
                }
                this.phase = 'END';
                this.handleEndPhase();
                break;
            case 'END':
                this.switchTurn();
                break;
        }
        this.broadcastState();
    }

    public handleLevelUpPhase() {
        const player = this.players[this.turnPlayerId];
        if (!player) return;
        const oldLevel = player.state.leaderLevel;
        const targetLevel = Math.min(10, Math.ceil(this.turnCount / 2) + 1);
        player.state.leaderLevel = Math.max(player.state.leaderLevel, targetLevel);
        this.addLog(`${player.username} Level Up -> ${player.state.leaderLevel}`);
        if (player.state.leaderLevel > oldLevel) {
            this.broadcastAction(this.turnPlayerId, 'LEVEL_UP', { newLevel: player.state.leaderLevel });
        }
        const awakenLv = player.state.leader.id === 'ST01-001' ? 5 : (player.state.leader.awakeningLevel || 3);
        if (oldLevel < awakenLv && player.state.leaderLevel >= awakenLv) {
            this.addLog(`${player.username} Leader Awakened!`);
            this.broadcastAction(this.turnPlayerId, 'AWAKEN', { leader: player.state.leader.name });
            if (player.state.leader.effects) {
                player.state.leader.effects.forEach(effect => {
                    if (effect.trigger === 'ON_AWAKEN') {
                        this.applyEffect(this.turnPlayerId, player.state.leader, 'ON_AWAKEN', undefined, effect);
                    }
                });
            }
        }
    }

    public handleDrawPhase() {
        if (this.turnCount === 1) return;
        const player = this.players[this.turnPlayerId];
        if (!player) return;
        if (player.state.deck.length > 0) {
            player.drawCard(player.state.deck.pop()!);
        } else {
            // Deck Out during Draw Phase
            this.endGame(this.turnPlayerId, "山札切れ");
            return;
        }
        this.broadcastState();
    }

    public handleEndPhase() {
        const player = this.players[this.turnPlayerId];
        if (player) {
            // Move all skills from skillZone to discard at end of turn
            player.state.discard.push(...player.state.skillZone);
            player.state.skillZone = [];
        }
        this.broadcastAction(this.turnPlayerId, 'END_PHASE', {});
    }

    public playCard(playerId: string, cardIndex: number, targetInfo?: { slotIndex?: number, targetId?: string }) {
        if (this.phase === 'FINISHED') return;
        if (playerId !== this.turnPlayerId) return;
        if (this.phase !== 'MAIN') return;
        const player = this.players[playerId];
        if (!player) return;
        const hand = player.state.hand;
        if (cardIndex < 0 || cardIndex >= hand.length) return;
        const card = hand[cardIndex];
        const currentSize = player.state.field.reduce((sum, c) => {
            if (!c) return sum;
            let unitTotal = c.cost;
            if (c.attachments) {
                unitTotal += c.attachments.reduce((aSum, a) => aSum + a.cost, 0);
            }
            return sum + unitTotal;
        }, 0) + player.state.skillZone.reduce((sum, s) => sum + s.cost, 0);
        const sizeLimit = this.getSizeLimit(playerId);

        if (card.type === 'UNIT') {
            const slotIndex = targetInfo?.slotIndex;
            if (slotIndex === undefined || slotIndex < 0 || slotIndex > 2) return;
            if (player.state.unitsPlaced && player.state.unitsPlaced[slotIndex]) return;
            const existingUnit = player.state.field[slotIndex];
            if (existingUnit) {
                if (card.cost <= existingUnit.cost) return;
                player.state.discard.push(existingUnit);
            }
            if (currentSize + card.cost - (existingUnit ? existingUnit.cost : 0) > sizeLimit) return;
            player.state.hand.splice(cardIndex, 1);
            player.state.field[slotIndex] = card;
            if (player.state.unitsPlaced) player.state.unitsPlaced[slotIndex] = true;
            this.applyEffect(playerId, card, 'ON_PLAY', { slotIndex });
        } else if (card.type === 'ITEM') {
            const slotIndex = targetInfo?.slotIndex;
            if (slotIndex === undefined || slotIndex < 0 || slotIndex > 2) return;
            const targetUnit = player.state.field[slotIndex];
            if (!targetUnit) return;
            if (currentSize + card.cost > sizeLimit) return;
            player.state.hand.splice(cardIndex, 1);
            if (!targetUnit.attachments) targetUnit.attachments = [];
            targetUnit.attachments.push(card);
            this.applyEffect(playerId, card, 'ON_PLAY', { slotIndex });
        } else if (card.type === 'SKILL') {
            if (currentSize + card.cost > sizeLimit) return;
            player.state.hand.splice(cardIndex, 1);
            player.state.skillZone.push(card);
            this.applyEffect(playerId, card, 'ON_PLAY', targetInfo);
        }
        this.broadcastState();
    }

    public attack(playerId: string, attackerIndex: number, targetIndex: number) {
        if (playerId !== this.turnPlayerId) return;
        if (this.phase !== 'ATTACK') return;
        const player = this.players[playerId];
        if (!player) return;
        const attacker = player.state.field[attackerIndex];
        if (!attacker || attacker.type !== 'UNIT' || attacker.isStunned || attacker.cannotAttack || attacker.attackedThisTurn) return;
        const opponentId = Object.keys(this.players).find(id => id !== playerId);
        if (!opponentId) return;
        const opponent = this.players[opponentId];
        // targetIndex はアタッカーのレーン(attackerIndex)と同じである必要がある（対向ユニットへの攻撃）
        // クライアント側でリーダーをクリックした際に -1 が送られてくる場合は、attackerIndex に読み替える
        const effectiveTargetIndex = targetIndex === -1 ? attackerIndex : targetIndex;
        if (effectiveTargetIndex !== attackerIndex) return;

        const adjacentSlots = [attackerIndex - 1, attackerIndex + 1].filter(s => s >= 0 && s <= 2);
        const guardianCandidates = adjacentSlots.filter(s => {
            const u = opponent.state.field[s];
            return u && this.hasKeyword(u, 'GUARDIAN');
        });

        attacker.attackedThisTurn = true;
        this.applyEffect(playerId, attacker, 'ON_ATTACK', { slotIndex: attackerIndex });
        this.pendingAttack = { attackerId: playerId, attackerIndex, defenderId: opponentId, targetIndex: effectiveTargetIndex };
        if (guardianCandidates.length > 0) {
            this.phase = 'GUARDIAN_INTERCEPT';
            this.broadcastState();
            return;
        }
        this.finalizeAttackResolution();
    }

    private finalizeAttackResolution() {
        if (!this.pendingAttack) return;
        const { attackerId, attackerIndex, defenderId, targetIndex } = this.pendingAttack;
        const defenderPlayer = this.players[defenderId];
        const defender = defenderPlayer.state.field[targetIndex];

        if (!defender) {
            // Direct Attack
            const attacker = this.players[attackerId].state.field[attackerIndex];
            if (attacker) {
                const hitCount = this.getUnitHitCount(attackerId, attackerIndex);
                this.dealDamage(defenderId, hitCount);
                this.addLog(`${this.players[attackerId].username}'s unit dealt ${hitCount} damage to leader.`);
            }
            // --- FIX: Prevent overwriting selection phase ---
            if ((this.phase as any) !== 'SELECT_CARD') {
                this.phase = 'ATTACK';
            }
            this.pendingAttack = null;
        } else {
            this.phase = 'DEFENSE';
        }
        this.broadcastState();
    }

    public resolveGuardianIntercept(playerId: string, interceptSlot: number | 'NONE') {
        if (this.phase !== 'GUARDIAN_INTERCEPT' || !this.pendingAttack) return;
        if (playerId !== this.pendingAttack.defenderId) return;
        if (interceptSlot === 'NONE') {
            this.finalizeAttackResolution();
        } else {
            const defender = this.players[playerId];
            const unit = defender.state.field[interceptSlot];
            if (unit && this.hasKeyword(unit, 'GUARDIAN')) {
                this.pendingAttack.targetIndex = interceptSlot;
                this.finalizeAttackResolution();
            }
        }
    }

    public resolveDefense(playerId: string, action: 'BLOCK' | 'TAKE') {
        if (this.phase !== 'DEFENSE' || !this.pendingAttack) return;
        if (playerId !== this.pendingAttack.defenderId) return;
        const { attackerId, attackerIndex, defenderId, targetIndex } = this.pendingAttack;
        const attackerPlayer = this.players[attackerId];
        const defenderPlayer = this.players[defenderId];
        const attacker = attackerPlayer.state.field[attackerIndex];
        const defender = defenderPlayer.state.field[targetIndex];

        if (action === 'BLOCK' && attacker && this.hasKeyword(attacker, 'BREAKTHROUGH')) {
            // Cannot block due to Breakthrough
            return;
        }
        if (!attacker || !defender) {
            this.phase = 'ATTACK';
            this.pendingAttack = null;
            this.broadcastState();
            return;
        }

        if (action === 'BLOCK') {
            const attPower = this.getUnitPower(attackerId, attackerIndex);
            const defPower = this.getUnitPower(defenderId, targetIndex);

            const attackerInvincible = this.hasKeyword(attacker, 'INVINCIBLE');
            const defenderInvincible = this.hasKeyword(defender, 'INVINCIBLE');

            if (attPower >= defPower) {
                if (!defenderInvincible) {
                    this.destroyUnit(defenderId, targetIndex, attackerId, attackerIndex);

                    // LOOT Keyword
                    if (this.hasKeyword(attacker, 'LOOT')) {
                        const lootValue = this.getKeywordValue(attacker, 'LOOT');
                        for (let i = 0; i < lootValue; i++) {
                            if (attackerPlayer.state.deck.length > 0) {
                                attackerPlayer.drawCard(attackerPlayer.state.deck.pop()!);
                            }
                        }
                        this.addLog(`${attacker.name} activated LOOT! Drawn ${lootValue} card(s).`);
                    }
                } else {
                    this.addLog(`${defender.name} is INVINCIBLE! Not destroyed.`);
                }

                if (this.hasKeyword(attacker, 'PENETRATION')) {
                    this.dealDamage(defenderId, this.getKeywordValue(attacker, 'PENETRATION'));
                }
            } else {
                if (!attackerInvincible) {
                    this.destroyUnit(attackerId, attackerIndex, defenderId, targetIndex);
                } else {
                    this.addLog(`${attacker.name} is INVINCIBLE! Not destroyed.`);
                }
            }
        } else {
            const hitCount = this.getUnitHitCount(attackerId, attackerIndex);
            this.dealDamage(defenderId, hitCount);
        }
        // --- FIX: Prevent overwriting selection phase ---
        if ((this.phase as any) !== 'SELECT_CARD') {
            this.phase = 'ATTACK';
        }
        this.pendingAttack = null;
        this.checkStateBasedActions();
        this.broadcastState();
    }

    public resolveSelection(playerId: string, selectedIds: string[]) {
        if (!this.selection || playerId !== this.selection.playerId) return;
        const player = this.players[playerId];
        const action = this.selection.action;
        if (action === 'ADD_TO_HAND_FROM_DECK') {
            selectedIds.forEach(id => {
                const idx = player.state.deck.findIndex(c => c.id === id);
                if (idx !== -1) player.drawCard(player.state.deck.splice(idx, 1)[0]);
            });
        } else if (action === 'ADD_TO_HAND') {
            selectedIds.forEach(id => {
                const idx = player.state.discard.findIndex(c => c.id === id);
                if (idx !== -1) player.drawCard(player.state.discard.splice(idx, 1)[0]);
            });
        } else if (action === 'DISCARD_HAND') {
            selectedIds.forEach(id => {
                const idx = player.state.hand.findIndex(c => c.id === id);
                if (idx !== -1) {
                    const [card] = player.state.hand.splice(idx, 1);
                    player.state.discard.push(card);
                }
            });
        } else if (action === 'KILL_UNIT_SELECTION') {
            // For trigger-based kill effects
            const opponentId = (this.selection.context as any)?.opponentId;
            if (opponentId && selectedIds.length > 0) {
                const opponent = this.players[opponentId];
                const selectedId = selectedIds[0];
                const slotIndex = opponent.state.field.findIndex(u => u?.id === selectedId);
                if (slotIndex !== -1) {
                    this.destroyUnit(opponentId, slotIndex);
                }
            }
        } else if (action === 'BOUNCE_UNIT_SELECTION') {
            // For bounce effects - return unit and items to hand
            const opponentId = (this.selection.context as any)?.opponentId;
            if (opponentId && selectedIds.length > 0) {
                const opponent = this.players[opponentId];
                const selectedId = selectedIds[0];
                const slotIndex = opponent.state.field.findIndex(u => u?.id === selectedId);
                if (slotIndex !== -1) {
                    const unit = opponent.state.field[slotIndex];
                    if (unit) {
                        // Return unit to hand
                        opponent.drawCard(unit);

                        // Return all equipped items to hand
                        if (unit.attachments && unit.attachments.length > 0) {
                            unit.attachments.forEach(item => {
                                opponent.drawCard(item);
                            });
                            unit.attachments = []; // Clear attachments
                        }

                        // Remove unit from field
                        opponent.state.field[slotIndex] = null;
                        this.addLog(`${unit.name} and its items were returned to hand.`);
                    }
                }
            }
        } else if (action === 'SWAP_DAMAGE_STEP_1') {
            // SWAP_DAMAGE_HAND Step 1: Move selected item from damage zone to hand
            if (selectedIds.length > 0) {
                const selectedId = selectedIds[0];
                const idx = player.state.damageZone.findIndex(c => c.id === selectedId);
                if (idx !== -1) {
                    const [card] = player.state.damageZone.splice(idx, 1);
                    player.drawCard(card);
                    this.addLog(`${card.name} moved from damage zone to hand.`);

                    // Step 2: Request selection from hand to move to damage zone
                    if (player.state.hand.length > 0) {
                        this.requestSelection(playerId, 'HAND', player.state.hand.map(c => c.id), 1, 'SWAP_DAMAGE_STEP_2');
                    }
                }
            }
        } else if (action === 'SWAP_DAMAGE_STEP_2') {
            // SWAP_DAMAGE_HAND Step 2: Move selected card from hand to damage zone
            if (selectedIds.length > 0) {
                const selectedId = selectedIds[0];
                const idx = player.state.hand.findIndex(c => c.id === selectedId);
                if (idx !== -1) {
                    const [card] = player.state.hand.splice(idx, 1);
                    player.state.damageZone.push(card);
                    this.addLog(`${card.name} moved from hand to damage zone.`);
                }
            }
        } else if (action === 'DEBUFF_ENEMY_SELECTION') {
            if (selectedIds.length > 0) {
                const selectedId = selectedIds[0];
                const opponentId = (this.selection.context as any)?.opponentId;
                const value = (this.selection.context as any)?.value || 0;
                const drawOnKill = (this.selection.context as any)?.drawOnKill;
                if (opponentId) {
                    const opponent = this.players[opponentId];
                    const slotIndex = opponent.state.field.findIndex(u => u?.id === selectedId);
                    if (slotIndex !== -1) {
                        const unit = opponent.state.field[slotIndex];
                        if (unit) {
                            if (!unit.tempPowerDebuff) unit.tempPowerDebuff = 0;
                            unit.tempPowerDebuff += value;
                            this.addLog(`${unit.name} power -${value} by trigger.`);
                            this.checkDrawOnKill(playerId, opponentId, slotIndex, drawOnKill);
                        }
                    }
                }
            }
        }
        else if (action === 'COST_BASED_KILL_STEP_1') {
            // COST_BASED_KILL Step 1: Discard selected unit from hand and get its cost
            const opponentId = (this.selection.context as any)?.opponentId;
            if (selectedIds.length > 0 && opponentId) {
                const selectedId = selectedIds[0];
                const idx = player.state.hand.findIndex(c => c.id === selectedId);
                if (idx !== -1) {
                    const [card] = player.state.hand.splice(idx, 1);
                    player.state.discard.push(card);
                    const discardedCost = card.cost || 0;
                    this.addLog(`${card.name} (Cost ${discardedCost}) discarded from hand.`);

                    // Step 2: Request selection of enemy unit with cost lower than discarded card
                    const opponent = this.players[opponentId];
                    const validTargets: number[] = [];
                    opponent.state.field.forEach((unit, idx) => {
                        if (unit && (unit.cost || 0) < discardedCost) {
                            validTargets.push(idx);
                        }
                    });

                    if (validTargets.length > 0) {
                        this.requestSelection(playerId, 'FIELD', validTargets.map(idx => opponent.state.field[idx]!.id), 1, 'COST_BASED_KILL_STEP_2', { opponentId });
                    }
                }
            }
        } else if (action === 'SUMMON_SELECTION') {
            if (selectedIds.length > 0) {
                const id = selectedIds[0];
                const idx = player.state.discard.findIndex(c => c.id === id);
                if (idx !== -1) {
                    const [card] = player.state.discard.splice(idx, 1);
                    const freeSlot = player.state.field.findIndex(s => s === null);
                    if (freeSlot !== -1) {
                        player.state.field[freeSlot] = card;
                        this.addLog(`${card.name} resurrected from trash to field.`);
                    } else {
                        player.state.discard.push(card);
                        this.addLog(`No space on field for ${card.name}.`);
                    }
                }
            }
        } else if (action === 'BOUNCE_UNIT_SELECTION') {
            const opponentId = (this.selection.context as any)?.opponentId;
            if (opponentId && selectedIds.length > 0) {
                const opponent = this.players[opponentId];
                const selectedId = selectedIds[0];
                const slotIndex = opponent.state.field.findIndex(u => u?.id === selectedId);
                if (slotIndex !== -1) {
                    const unit = opponent.state.field[slotIndex]!;
                    // Bounce unit and all attachments
                    if (unit.attachments) {
                        unit.attachments.forEach(item => {
                            opponent.drawCard(item);
                        });
                        unit.attachments = [];
                    }
                    opponent.drawCard(unit);
                    opponent.state.field[slotIndex] = null;
                    this.addLog(`${unit.name} returned to hand.`);
                }
            }
        } else if (action === 'DISCARD_HAND') {
            selectedIds.forEach(id => {
                const idx = player.state.hand.findIndex(c => c.id === id);
                if (idx !== -1) {
                    const [card] = player.state.hand.splice(idx, 1);
                    player.state.discard.push(card);
                    this.addLog(`${player.username} discarded ${card.name}.`);
                }
            });
        } else if (action === 'COST_BASED_KILL_STEP_1') {
            const opponentId = (this.selection.context as any)?.opponentId;
            if (opponentId && selectedIds.length > 0) {
                const id = selectedIds[0];
                const idx = player.state.hand.findIndex(c => c.id === id);
                if (idx !== -1) {
                    const [card] = player.state.hand.splice(idx, 1);
                    player.state.discard.push(card);
                    this.addLog(`${player.username} discarded ${card.name} for cost-based kill.`);

                    // Now select enemy unit with cost < discardedCost
                    const discardedCost = card.cost || 0;
                    const opponent = this.players[opponentId];
                    const validTargets: number[] = [];
                    opponent.state.field.forEach((unit, idx) => {
                        if (unit && (unit.cost || 0) < discardedCost) {
                            validTargets.push(idx);
                        }
                    });

                    if (validTargets.length > 0) {
                        this.requestSelection(playerId, 'FIELD', validTargets.map(idx => opponent.state.field[idx]!.id), 1, 'COST_BASED_KILL_STEP_2', { opponentId }, this.selection?.triggerCard);
                    }
                }
            }
        } else if (action === 'COST_BASED_KILL_STEP_2') {
            const opponentId = (this.selection.context as any)?.opponentId;
            if (opponentId && selectedIds.length > 0) {
                const opponent = this.players[opponentId];
                const selectedId = selectedIds[0];
                const slotIndex = opponent.state.field.findIndex(u => u?.id === selectedId);
                if (slotIndex !== -1) {
                    this.destroyUnit(opponentId, slotIndex);
                }
            }
        } else if (action === 'RECYCLE_SELECTION') {
            selectedIds.forEach(id => {
                const idx = player.state.discard.findIndex(c => c.id === id);
                if (idx !== -1) {
                    const [card] = player.state.discard.splice(idx, 1);
                    player.state.deck.unshift(card);
                }
            });
            this.addLog(`${selectedIds.length} cards recycled to deck bottom.`);
        } else if (action === 'GRANT_ABILITY_SELECTION') {
            const keywordsStr = (this.selection.context as any)?.keywords;
            const keywords = keywordsStr?.split(',') || [];
            if (selectedIds.length > 0) {
                const selectedId = selectedIds[0];
                const unit = player.state.field.find(u => u?.id === selectedId);
                if (unit) {
                    if (!unit.tempKeywords) unit.tempKeywords = [];
                    keywords.forEach((k: string) => {
                        if (!unit.tempKeywords!.includes(k)) unit.tempKeywords!.push(k);
                    });
                    this.addLog(`${unit.name} gained [${keywords.join(', ')}] until turn end.`);
                }
            }
        }
        this.phase = (this.selection as any).previousPhase || 'MAIN';
        this.selection = null;
        this.checkStateBasedActions();
        this.broadcastState();
    }
    public resolveMulligan(playerId: string, selectedIds: string[]) {
        if (this.phase !== 'MULLIGAN') return;
        const player = this.players[playerId];
        if (!player || player.state.mulliganDone) return;
        selectedIds.forEach(id => {
            const idx = player.state.hand.findIndex(c => c.id === id);
            if (idx !== -1) {
                const [card] = player.state.hand.splice(idx, 1);
                player.state.deck.unshift(card);
            }
        });
        if (selectedIds.length > 0) {
            player.state.deck.sort(() => Math.random() - 0.5);
            while (player.state.hand.length < 5) {
                player.drawCard(player.state.deck.pop()!);
            }
        }
        player.state.mulliganDone = true;
        if (Object.values(this.players).every(p => p.state.mulliganDone)) {
            this.phase = 'LEVEL_UP';
            this.handleLevelUpPhase();
        }
        this.broadcastState();
    }

    public useActiveAbility(playerId: string, slotIndex: number) {
        if (this.phase !== 'MAIN' || playerId !== this.turnPlayerId) return;
        const player = this.players[playerId];
        const unit = player.state.field[slotIndex];
        if (!unit || unit.activeUsedThisTurn) return;
        if (unit.effects) {
            unit.effects.forEach(e => {
                if (e.trigger === 'ACTIVE') this.applyEffect(playerId, unit, 'ACTIVE', { slotIndex });
            });
        }
        unit.activeUsedThisTurn = true;
        this.checkStateBasedActions();
        this.broadcastState();
    }

    public dealDamage(playerId: string, amount: number = 1) {
        const player = this.players[playerId];
        if (!player) return;
        for (let i = 0; i < amount; i++) {
            if (player.state.deck.length > 0) {
                const damageCard = player.state.deck.pop()!;
                player.state.hp++;
                const isTrigger = !!(damageCard.effects?.some(e => e.trigger === 'ON_DAMAGE_TRIGGER'));
                this.broadcastAction(playerId, 'DAMAGE_REVEAL', {
                    card: damageCard,
                    isTrigger,
                    playerName: player.username
                });

                if (isTrigger) {
                    this.applyEffect(playerId, damageCard, 'ON_DAMAGE_TRIGGER');

                    // Check if any trigger effect requires trashing this card
                    const shouldTrash = damageCard.effects?.some(e =>
                        e.trigger === 'ON_DAMAGE_TRIGGER' && e.isSelfTrash
                    );

                    if (shouldTrash) {
                        // Move to discard instead of damage zone
                        player.state.discard.push(damageCard);
                        this.addLog(`${damageCard.name} was trashed by trigger effect.`);
                    } else if (!(damageCard as any)._skipDamageZone) {
                        player.state.damageZone.push(damageCard);
                    }
                } else if (!(damageCard as any)._skipDamageZone) {
                    player.state.damageZone.push(damageCard);
                }

                // Check Damage Loss
                if (player.state.damageZone.length >= 10) {
                    this.endGame(playerId, "ダメージが10に達した");
                    return;
                }
            } else {
                // Deck Out during Damage
                this.endGame(playerId, "山札切れ（ダメージ）");
                return;
            }
        }
        this.broadcastState();
    }

    public applyEffect(playerId: string, card: Card, trigger: string, context?: Record<string, unknown>, specificEffect?: CardEffect) {
        const player = this.players[playerId];
        if (!player) return;

        const effectContext = context as {
            tempPowerRef?: { power: number },
            slotIndex?: number,
            targetSlot?: number,
            killSlot?: number,
            value?: number
        } | undefined;

        const opponentId = Object.keys(this.players).find(id => id !== playerId);
        const opponent = opponentId ? this.players[opponentId] : null;

        let effectsToProcess = [...(card?.effects || [])];
        if (card.attachments) {
            card.attachments.forEach(item => {
                if (item.effects) {
                    effectsToProcess.push(...item.effects);
                }
            });
        }

        if (specificEffect) {
            effectsToProcess = [specificEffect];
        }

        effectsToProcess.forEach(effect => {
            if (effect.trigger !== trigger) return;

            // --- Awakening Check ---
            if (effect.isAwakening && player.state.leaderLevel < (card.awakeningLevel || 0)) {
                console.log(`[Game] Skipping Awakening Effect: ${effect.action} (Leader Level ${player.state.leaderLevel} < ${card.awakeningLevel})`);
                return;
            }

            // --- Condition Check ---
            if (effect.condition) {
                if (effect.condition === 'ARMED_GE_3') {
                    const itemNum = card.attachments?.length || 0;
                    if (itemNum < 3) return;
                }
                if (effect.condition === 'ARMED_IF_EQUIPPED') {
                    const itemNum = card.attachments?.length || 0;
                    if (itemNum === 0) return;
                }
                if (effect.condition === 'ARMED_UNIQUE_IF_EQUIPPED') {
                    const hasUnique = card.attachments?.some(item =>
                        item.affiliation?.includes('ユニーク') || item.text?.includes('《ユニーク》') || item.name?.includes('ユニーク')
                    );
                    if (!hasUnique) return;
                }
            }

            console.log(`[Game] Applying Effect: ${effect.action} (Trigger: ${trigger})`);

            switch (effect.action) {
                case 'DRAW': {
                    const amount = effect.value || 1;
                    for (let i = 0; i < amount; i++) {
                        if (player.state.deck.length > 0) {
                            const drawn = player.state.deck.pop();
                            if (drawn) player.drawCard(drawn);
                        }
                    }
                    break;
                }
                case 'SEARCH_DECK': {
                    let candidates: Card[] = [];
                    if (effect.targetType === 'DECK_TOP') {
                        const count = effect.value || 3;
                        candidates = player.state.deck.slice(-count).reverse();
                    } else {
                        candidates = player.state.deck;
                    }

                    // Apply all filters
                    if (effect.condition) {
                        const conditions = effect.condition.split('_AND_');
                        conditions.forEach(cond => {
                            if (cond === 'TYPE_UNIT') {
                                candidates = candidates.filter(c => c.type === 'UNIT');
                            } else if (cond === 'TYPE_ITEM') {
                                candidates = candidates.filter(c => c.type === 'ITEM');
                            } else if (cond.startsWith('COST_LE_')) {
                                const cost = parseInt(cond.replace('COST_LE_', ''), 10);
                                candidates = candidates.filter(c => (c.cost || 0) <= cost);
                            }
                        });
                    }

                    const candidateIds = candidates.map(c => c.id);
                    if (candidateIds.length > 0) {
                        this.requestSelection(playerId, 'DECK', candidateIds, 1, 'ADD_TO_HAND_FROM_DECK', { targetType: effect.targetType }, card);
                    }
                    break;
                }
                case 'DAMAGE_UNIT': {
                    if (!opponent) return;
                    const slotIndex = effectContext?.slotIndex ?? effectContext?.targetSlot;
                    if (effect.targetType === 'ALL_ENEMIES') {
                        opponent.state.field.forEach((u, i) => {
                            if (u && u.power !== undefined && effect.value) {
                                u.power -= effect.value;
                            }
                        });
                    } else if (effect.targetType === 'OPPOSING') {
                        const slotIndex = effectContext?.slotIndex;
                        if (typeof slotIndex === 'number') {
                            const targetUnit = opponent.state.field[slotIndex];
                            if (targetUnit && targetUnit.power !== undefined && effect.value) {
                                targetUnit.power -= effect.value;
                            }
                        }
                    } else if (typeof slotIndex === 'number') {
                        const targetUnit = opponent.state.field[slotIndex];
                        if (targetUnit && targetUnit.power !== undefined && effect.value) {
                            // ITEM_SHIELD Check
                            if (this.hasKeyword(targetUnit, 'ITEM_SHIELD') && targetUnit.attachments && targetUnit.attachments.length > 0) {
                                this.addLog(`!! ${targetUnit.name} blocked damage with ITEM_SHIELD.`);
                                return;
                            }
                            targetUnit.power -= effect.value;
                        }
                    }
                    break;
                }
                case 'BUFF_ALLY': {
                    const slotIndex = effectContext?.slotIndex;
                    if (typeof slotIndex === 'number') {
                        const targetUnit = player.state.field[slotIndex];
                        if (targetUnit && targetUnit.power !== undefined) {
                            if (!targetUnit.tempPowerBuff) targetUnit.tempPowerBuff = 0;
                            targetUnit.tempPowerBuff += (effect.value || 0);
                        }
                    } else if (effect.targetType === 'SELF') {
                        const selfIndex = player.state.field.findIndex(u => u && u.id === card.id);
                        if (selfIndex !== -1 && player.state.field[selfIndex]) {
                            const unit = player.state.field[selfIndex]!;
                            if (!unit.tempPowerBuff) unit.tempPowerBuff = 0;
                            unit.tempPowerBuff += (effect.value || 0);
                        }
                    } else if (effect.targetType === 'ALL_ALLIES') {
                        player.state.field.forEach(u => {
                            if (u) {
                                if (!u.tempPowerBuff) u.tempPowerBuff = 0;
                                u.tempPowerBuff += (effect.value || 0);
                            }
                        });
                    }
                    break;
                }
                case 'BUFF_HIT': {
                    const slotIndex = effectContext?.slotIndex;
                    if (typeof slotIndex === 'number') {
                        const targetUnit = player.state.field[slotIndex];
                        if (targetUnit) {
                            if (!targetUnit.tempHitBuff) targetUnit.tempHitBuff = 0;
                            targetUnit.tempHitBuff += (effect.value || 0);
                        }
                    } else if (effect.targetType === 'SELF') {
                        const selfIndex = player.state.field.findIndex(u => u && u.id === card.id);
                        if (selfIndex !== -1 && player.state.field[selfIndex]) {
                            const unit = player.state.field[selfIndex]!;
                            if (!unit.tempHitBuff) unit.tempHitBuff = 0;
                            unit.tempHitBuff += (effect.value || 0);
                        }
                    }
                    break;
                }
                case 'DEAL_DAMAGE_PLAYER': {
                    if (!opponentId) return;
                    this.dealDamage(opponentId, effect.value || 1);
                    break;
                }
                case 'DEBUFF_ENEMY': {
                    if (!opponent) return;
                    if (effect.targetType === 'ALL_ENEMIES') {
                        opponent.state.field.forEach(u => {
                            if (u) {
                                if (!u.tempPowerDebuff) u.tempPowerDebuff = 0;
                                u.tempPowerDebuff += (effect.value || 0);
                            }
                        });
                    } else if (effect.targetType === 'OPPOSING') {
                        const slotIndex = effectContext?.slotIndex;
                        if (typeof slotIndex === 'number') {
                            const u = opponent.state.field[slotIndex];
                            if (u) {
                                if (!u.tempPowerDebuff) u.tempPowerDebuff = 0;
                                u.tempPowerDebuff += (effect.value || 0);
                                if (opponentId) this.checkDrawOnKill(playerId, opponentId, slotIndex, effect.drawOnKill);
                            }
                        }
                    } else if (effect.targetType === 'SINGLE') {
                        // Request selection for manual target
                        const candidates = opponent.state.field.filter(u => u !== null).map(u => u!.id);
                        if (candidates.length > 0 && opponentId) {
                            this.requestSelection(playerId, 'FIELD', candidates, 1, 'DEBUFF_ENEMY_SELECTION', {
                                opponentId,
                                value: effect.value,
                                drawOnKill: effect.drawOnKill
                            }, card);
                        }
                    }
                    break;
                }
                case 'STUN_UNIT': {
                    if (!opponent) return;
                    if (effect.targetType === 'SINGLE' && typeof effectContext?.targetSlot === 'number') {
                        const u = opponent.state.field[effectContext.targetSlot];
                        if (u) u.isStunned = true;
                    } else if (effect.targetType === 'OPPOSING') {
                        const slotIndex = effectContext?.slotIndex;
                        if (typeof slotIndex === 'number') {
                            const u = opponent.state.field[slotIndex];
                            if (u) u.isStunned = true;
                        }
                    }
                    break;
                }
                case 'HEAL_LEADER': {
                    const heal = effect.value || 1;
                    if (player.state.hp > 0) {
                        player.state.hp = Math.max(0, player.state.hp - heal);
                    }
                    break;
                }
                case 'KILL_UNIT': {
                    if (!opponent) return;
                    const targetSlot = effectContext?.targetSlot;

                    if (effect.targetType === 'OPPOSING') {
                        const slotIndex = effectContext?.slotIndex;
                        if (typeof slotIndex === 'number' && opponentId) {
                            this.destroyUnit(opponentId, slotIndex);
                        }
                    } else if (effect.targetType === 'SINGLE') {
                        // For trigger effects, need to select from valid targets
                        if (trigger === 'ON_DAMAGE_TRIGGER' || trigger === 'ON_PLAY') {
                            // Filter candidates by cost condition
                            const candidates: number[] = [];
                            opponent.state.field.forEach((unit, idx) => {
                                if (!unit) return;

                                // Check cost condition
                                if (effect.condition && effect.condition.startsWith('COST_LE_')) {
                                    const maxCost = parseInt(effect.condition.replace('COST_LE_', ''), 10);
                                    if ((unit.cost || 0) > maxCost) return;
                                }

                                candidates.push(idx);
                            });

                            if (candidates.length > 0 && opponentId) {
                                // Request selection from valid targets
                                this.requestSelection(playerId, 'FIELD', candidates.map(idx => opponent.state.field[idx]!.id), 1, 'KILL_UNIT_SELECTION', { opponentId }, card);
                            }
                        } else if (typeof targetSlot === 'number' && opponentId) {
                            this.destroyUnit(opponentId, targetSlot);
                        }
                    }
                    break;
                }
                case 'BOUNCE_UNIT': {
                    if (!opponent || !opponentId) return;

                    if (effect.targetType === 'SINGLE') {
                        if (trigger === 'ON_DAMAGE_TRIGGER' || trigger === 'ON_PLAY') {
                            // Filter candidates by condition
                            let candidates: number[] = [];

                            if (effect.condition === 'LOWEST_COST') {
                                // Find lowest cost unit(s)
                                let lowestCost = Infinity;
                                opponent.state.field.forEach((unit, idx) => {
                                    if (unit && (unit.cost || 0) < lowestCost) {
                                        lowestCost = unit.cost || 0;
                                    }
                                });

                                opponent.state.field.forEach((unit, idx) => {
                                    if (unit && (unit.cost || 0) === lowestCost) {
                                        candidates.push(idx);
                                    }
                                });
                            } else {
                                // All units are candidates
                                opponent.state.field.forEach((unit, idx) => {
                                    if (unit) candidates.push(idx);
                                });
                            }

                            if (candidates.length > 0) {
                                this.requestSelection(playerId, 'FIELD', candidates.map(idx => opponent.state.field[idx]!.id), 1, 'BOUNCE_UNIT_SELECTION', { opponentId }, card);
                            }
                        }
                    }
                    break;
                }
                case 'SWAP_DAMAGE_HAND': {
                    // Step 1: Select item card from damage zone to add to hand
                    let candidates: Card[] = [];

                    if (effect.targetType === 'DAMAGE_ITEM') {
                        // Filter damage zone for item cards
                        candidates = player.state.damageZone.filter(c => c.type === 'ITEM');
                    }

                    if (candidates.length > 0) {
                        this.requestSelection(playerId, 'DAMAGE_ZONE', candidates.map(c => c.id), 1, 'SWAP_DAMAGE_STEP_1', undefined, card);
                    }
                    break;
                }
                case 'COST_BASED_KILL': {
                    // Step 1: Select unit card from hand to discard
                    if (effect.targetType === 'HAND_UNIT') {
                        const unitCards = player.state.hand.filter(c => c.type === 'UNIT');
                        if (unitCards.length > 0) {
                            this.requestSelection(playerId, 'HAND', unitCards.map(c => c.id), 1, 'COST_BASED_KILL_STEP_1', { opponentId }, card);
                        }
                    }
                    break;
                }
                case 'DISCARD': {
                    if (effect.targetType === 'SELF') {
                        // Player discards from own hand
                        const count = effect.value || 1;
                        if (player.state.hand.length > 0) {
                            this.requestSelection(playerId, 'HAND', player.state.hand.map(c => c.id), count, 'DISCARD_HAND', undefined, card);
                        }
                    } else {
                        // Opponent discards
                        if (!opponentId || !opponent) return;
                        this.requestSelection(opponentId, 'HAND', opponent.state.hand.map(c => c.id), 1, 'DISCARD_HAND', undefined, card);
                    }
                    break;
                }
                case 'ADD_FROM_DISCARD': {
                    // Often used as [Trigger] to add the trigger card to hand
                    if (effect.targetType === 'SELF') {
                        // In dealDamage, the card is pushed to damageZone AFTER applyEffect.
                        // So we need to remove it from where it's about to be or handle it specially.
                        // However, current dealDamage implementation:
                        // 1. pop from deck
                        // 2. applyEffect
                        // 3. push to damageZone
                        // So if we add to hand here, we should prevent it from being pushed to damageZone in dealDamage?
                        // That's tricky with current structure.
                        // Let's modify applyEffect return or state flag.
                        player.drawCard(card);
                        (card as any)._skipDamageZone = true;
                    } else if (effect.targetType === 'DISCARD') {
                        // Filter discard pile by conditions
                        let candidates = player.state.discard;

                        if (effect.condition) {
                            const conditions = effect.condition.split('_AND_');
                            conditions.forEach(cond => {
                                if (cond === 'TYPE_UNIT') {
                                    candidates = candidates.filter(c => c.type === 'UNIT');
                                } else if (cond === 'TYPE_ITEM') {
                                    candidates = candidates.filter(c => c.type === 'ITEM');
                                } else if (cond.startsWith('COST_LE_')) {
                                    const cost = parseInt(cond.replace('COST_LE_', ''), 10);
                                    candidates = candidates.filter(c => (c.cost || 0) <= cost);
                                }
                            });
                        }

                        if (candidates.length > 0) {
                            this.requestSelection(playerId, 'DISCARD', candidates.map(c => c.id), effect.value || 1, 'ADD_TO_HAND', undefined, card);
                        }
                    }
                    break;
                }
                case 'LEVEL_UP': {
                    const amount = effect.value || 1;
                    if (player.state.leaderLevel < 10) {
                        const oldLevel = player.state.leaderLevel;
                        player.state.leaderLevel = Math.min(10, player.state.leaderLevel + amount);
                        if (player.state.leaderLevel > oldLevel) {
                            this.broadcastAction(playerId, 'LEVEL_UP', { level: player.state.leaderLevel });
                        }
                    }
                    break;
                }
                case 'RECYCLE': {
                    const count = effect.value || 1;
                    if (player.state.discard.length > 0) {
                        const candidates = player.state.discard;
                        this.requestSelection(playerId, 'DISCARD', candidates.map(c => c.id), count, 'RECYCLE_SELECTION', undefined, card);
                    }
                    break;
                }
                case 'SET_POWER': {
                    const slotIndex = player.state.field.findIndex(u => u && u.id === card.id);
                    if (slotIndex !== -1 && player.state.field[slotIndex]) {
                        const unit = player.state.field[slotIndex]!;
                        const currentPower = this.getUnitPower(playerId, slotIndex);
                        const diff = (effect.value || 0) - currentPower;
                        if (!unit.tempPowerBuff) unit.tempPowerBuff = 0;
                        unit.tempPowerBuff += diff;
                    }
                    break;
                }
                case 'SALVAGE_EQUIPMENT': {
                    const items = card.attachments || [];
                    if (items.length > 0) {
                        // Simplified: Automically salvage the first item
                        const item = items[0];
                        player.drawCard(item);
                        this.addLog(`${item.name} salvaged from destroyed unit.`);
                    }
                    break;
                }
                case 'POWER_COPY_FRIEND': {
                    let maxPower = 0;
                    player.state.field.forEach((u, i) => {
                        if (u && this.hasKeyword(u, 'GUARDIAN')) {
                            const p = this.getUnitPower(playerId, i);
                            if (p > maxPower) maxPower = p;
                        }
                    });

                    if (maxPower > 0) {
                        const selfIndex = player.state.field.findIndex(u => u && u.id === card.id);
                        if (selfIndex !== -1) {
                            const self = player.state.field[selfIndex]!;
                            const currentSelf = this.getUnitPower(playerId, selfIndex);
                            const diff = maxPower - currentSelf;
                            if (!self.tempPowerBuff) self.tempPowerBuff = 0;
                            self.tempPowerBuff += diff;
                        }
                    }
                    break;
                }
                case 'RESTRICT_ATTACK': {
                    const targetType = effect.targetType;
                    if (targetType === 'SELF') {
                        const slotIndex = player.state.field.findIndex(u => u && u.id === card.id);
                        if (slotIndex !== -1 && player.state.field[slotIndex]) {
                            const unit = player.state.field[slotIndex]!;
                            if (effect.value === 0) { // Permanent
                                if (!unit.keywords) unit.keywords = [];
                                if (!unit.keywords.includes('PERMANENT_CANNOT_ATTACK')) {
                                    unit.keywords.push('PERMANENT_CANNOT_ATTACK');
                                }
                            }
                            unit.cannotAttack = true;
                        }
                    }
                    break;
                }
                case 'GRANT_ABILITY': {
                    const keywords = effect.grantedKeyword?.split(',') || [];
                    const targets: Card[] = [];
                    if (effect.targetType === 'SELF') {
                        const selfIndex = player.state.field.findIndex(u => u && u.id === card.id);
                        if (selfIndex !== -1 && player.state.field[selfIndex]) targets.push(player.state.field[selfIndex]!);
                    } else if (effect.targetType === 'SINGLE') {
                        // For play/trigger effects, request selection
                        if (trigger === 'ON_PLAY' || trigger === 'ON_DAMAGE_TRIGGER' || trigger === 'ACTIVE') {
                            const alliedUnits = player.state.field.filter(u => u !== null) as Card[];
                            if (alliedUnits.length > 0) {
                                this.requestSelection(playerId, 'FIELD', alliedUnits.map(u => u.id), 1, 'GRANT_ABILITY_SELECTION', { keywords: effect.grantedKeyword }, card);
                                return;
                            }
                        }
                    } else if (effect.targetType === 'ALL_ALLIES') {
                        player.state.field.forEach(u => { if (u) targets.push(u); });
                    }

                    targets.forEach(t => {
                        if (!t.tempKeywords) t.tempKeywords = [];
                        keywords.forEach((k: string) => {
                            if (!t.tempKeywords!.includes(k)) t.tempKeywords!.push(k);
                        });
                        this.addLog(`${t.name} gained [${keywords.join(', ')}] until turn end.`);
                    });
                    break;
                }
                case 'RESURRECT': {
                    let candidates = player.state.discard;
                    if (effect.condition) {
                        if (effect.condition.startsWith('COST_LE_')) {
                            const cost = parseInt(effect.condition.replace('COST_LE_', ''), 10);
                            candidates = candidates.filter(c => (c.cost || 0) <= cost);
                        }
                    }
                    if (candidates.length > 0) {
                        this.requestSelection(playerId, 'DISCARD', candidates.map(c => c.id), 1, 'SUMMON_SELECTION', undefined, card);
                    }
                    break;
                }
            }
        });
        this.checkStateBasedActions();
    }

    private getUnitPower(playerId: string, slotIndex: number): number {
        const player = this.players[playerId];
        const unit = player.state.field[slotIndex];
        if (!unit) return 0;
        let power = unit.power || 0;
        power += (unit.tempPowerBuff || 0);
        power -= (unit.tempPowerDebuff || 0);
        if (unit.attachments) {
            unit.attachments.forEach(a => {
                if (a.power) power += a.power;
                if (a.effects) {
                    a.effects.forEach(eff => {
                        if (eff.trigger === 'PASSIVE' && eff.action === 'BUFF_ALLY') {
                            power += (eff.value || 0);
                        }
                    });
                }
            });
        }

        // Leader Passives (Mirror GameBoard.tsx logic)
        if (player.state.leader.effects) {
            const isAwakened = player.state.leaderLevel >= (player.state.leader.awakeningLevel || 5);
            player.state.leader.effects.forEach(eff => {
                if (eff.trigger === 'PASSIVE' && eff.action === 'BUFF_ALLY') {
                    // Check Awakening requirement
                    if (eff.isAwakening && !isAwakened) return;

                    // Check MY_TURN if applicable
                    if (eff.condition?.includes('MY_TURN') && this.turnPlayerId !== playerId) return;

                    if (eff.condition === 'COUNT_UNITS') {
                        const count = player.state.field.filter(u => u !== null).length;
                        power += (eff.value || 0) * count;
                    } else if (eff.condition && eff.condition.startsWith('KEYWORD_')) {
                        const targetKeyword = eff.condition.replace('KEYWORD_', '');
                        if (this.hasKeyword(unit, targetKeyword)) {
                            power += (eff.value || 0);
                        }
                    } else if (player.state.leader.text?.includes('[アタッカー]') && player.state.leader.text?.includes('パワー+')) {
                        // Fallback for missing keyword condition in JSON
                        if (this.hasKeyword(unit, 'アタッカー')) {
                            power += (eff.value || 0);
                        }
                    } else if (!eff.condition || eff.condition === 'MY_TURN') {
                        // General buff to all allies
                        power += (eff.value || 0);
                    }
                }
            });
        }

        return Math.max(0, power);
    }

    private getUnitHitCount(playerId: string, slotIndex: number): number {
        const player = this.players[playerId];
        const unit = player.state.field[slotIndex];
        if (!unit) return 0;

        let hitCount = unit.hitCount || 1;
        if (unit.tempHitBuff) hitCount += unit.tempHitBuff;

        // INFILTRATE Keyword
        if (this.hasKeyword(unit, 'INFILTRATE')) {
            hitCount += this.getKeywordValue(unit, 'INFILTRATE');
        }

        // Attached Item Passives
        if (unit.attachments) {
            unit.attachments.forEach(a => {
                if (a.effects) {
                    a.effects.forEach(eff => {
                        if (eff.trigger === 'PASSIVE') {
                            if (eff.action === 'BUFF_HIT' || eff.action === 'SET_HIT') {
                                hitCount += (eff.value || 0);
                            }
                        }
                    });
                }
            });
        }

        // Card Passives (Mirror GameBoard.tsx logic)
        if (unit.effects) {
            unit.effects.forEach(eff => {
                if (eff.trigger === 'PASSIVE' && eff.action === 'SET_HIT') {
                    if (eff.condition === 'FIELD_FULL') {
                        const isFull = player.state.field.every(u => u !== null);
                        if (isFull) hitCount += (eff.value || 0);
                    }
                    if (eff.condition === 'COUNT_BASE') {
                        const baseCount = player.state.field.filter(u => u?.affiliation?.includes('ベース')).length;
                        hitCount += (eff.value || 1) * baseCount;
                    }
                }
            });
        }

        return hitCount;
    }

    private destroyUnit(playerId: string, slotIndex: number, killerId?: string, killerSlot?: number) {
        const player = this.players[playerId];
        const unit = player.state.field[slotIndex];
        if (!unit) return;
        const unitId = unit.id;

        // Trigger ON_DESTROY effects
        this.applyEffect(playerId, unit, 'ON_DESTROY');

        player.state.discard.push(unit);
        player.state.field[slotIndex] = null;
        this.addLog(`${unit.name} destroyed`);

        // Death Touch Logic
        if (this.hasKeyword(unit, 'DEATH_TOUCH') && killerId && typeof killerSlot === 'number') {
            const killerPlayer = this.players[killerId];
            const killerUnit = killerPlayer.state.field[killerSlot];
            if (killerUnit && !this.hasKeyword(killerUnit, 'INVINCIBLE')) {
                this.addLog(`${unit.name}'s DEATH_TOUCH activated! Destroying ${killerUnit.name}.`);
                // Note: We call destroyUnit recursively, but without killer info to avoid infinite loop
                this.destroyUnit(killerId, killerSlot);
            }
        }

        // Trigger ON_OTHER_UNIT_DESTROY for other units on the field
        Object.keys(this.players).forEach(pId => {
            const p = this.players[pId];
            p.state.field.forEach((u, i) => {
                if (u && u.id !== unitId && u.effects) {
                    u.effects.forEach(e => {
                        if (e.trigger === 'ON_OTHER_UNIT_DESTROY') {
                            this.applyEffect(pId, u, 'ON_OTHER_UNIT_DESTROY', { slotIndex: i, destroyedUnitId: unitId });
                        }
                    });
                }
            });
        });
    }

    private checkBerserkerMustAttack(): boolean {
        const player = this.players[this.turnPlayerId];
        if (!player) return false;
        return player.state.field.some(u => u && this.hasKeyword(u, 'BERSERKER') && !u.isStunned && !u.cannotAttack && !u.attackedThisTurn);
    }

    private checkStateBasedActions() {
        // Check for units with 0 or less power and destroy them
        Object.keys(this.players).forEach(playerId => {
            const player = this.players[playerId];
            player.state.field.forEach((unit, slotIndex) => {
                if (unit) {
                    const currentPower = this.getUnitPower(playerId, slotIndex);
                    if (currentPower <= 0) {
                        this.addLog(`!! ${unit.name} destroyed due to 0 power.`);
                        this.destroyUnit(playerId, slotIndex);
                    }
                }
            });
        });
    }

    private endGame(loserId: string, reason: string) {
        if (this.phase === 'FINISHED') return;

        const winnerId = Object.keys(this.players).find(id => id !== loserId);
        if (!winnerId) return; // Should not happen

        this.phase = 'FINISHED';
        this.broadcastAction(winnerId, 'GAME_OVER', {
            winnerId,
            loserId,
            reason
        });

        const winnerName = this.players[winnerId].username;
        this.addLog(`${winnerName} Wins! Reason: ${reason}`);
    }

    public broadcastState() {
        const state: any = {
            roomId: this.id,
            phase: this.phase,
            turnPlayerId: this.turnPlayerId,
            turnCount: this.turnCount,
            players: {},
            selection: this.selection,
            pendingAttack: this.pendingAttack,
            debugLogs: this.debugLogs
        };
        Object.values(this.players).forEach(p => {
            state.players[p.id] = p.state;
        });

        Object.values(this.players).forEach(p => {
            if (p.socket && (p.socket as any).emit) {
                p.socket.emit('gameState', state);
            }
        });

        // Check for AI Actions
        Object.values(this.players).forEach(p => {
            if (p.isCPU && (p as any).think) {
                // If it's the CPU's turn or CPU needs to select something
                if (this.turnPlayerId === p.id || this.selection?.playerId === p.id || this.phase === 'MULLIGAN') {
                    (p as any).think();
                }
            }
        });
    }

    public broadcastAction(playerId: string, actionType: string, data: unknown) {
        Object.values(this.players).forEach(p => {
            p.socket.emit('gameAction', { playerId, actionType, data });
        });
    }

    private addLog(msg: string) {
        this.debugLogs.push(msg);
        if (this.debugLogs.length > 50) this.debugLogs.shift();
        console.log(`[Game Log] ${msg}`);
    }

    private requestSelection(playerId: string, type: 'DECK' | 'DISCARD' | 'HAND' | 'FIELD' | 'DAMAGE_ZONE', candidateIds: string[], count: number, action: string, context?: Record<string, unknown>, triggerCard?: Card) {
        this.selection = { playerId, type, candidateIds, count, action, context, triggerCard, previousPhase: this.phase };
        this.phase = 'SELECT_CARD';
        this.broadcastState();
    }

    private getSizeLimit(playerId: string): number {
        const player = this.players[playerId];
        if (!player) return 0;
        return player.state.leaderLevel + player.state.hp;
    }

    private checkDrawOnKill(playerId: string, opponentId: string, slotIndex: number, drawOnKill?: number) {
        if (!drawOnKill) return;
        const opponent = this.players[opponentId];
        if (!opponent.state.field[slotIndex]) {
            const player = this.players[playerId];
            for (let i = 0; i < drawOnKill; i++) {
                if (player.state.deck.length > 0) player.drawCard(player.state.deck.pop()!);
            }
        }
    }
}
